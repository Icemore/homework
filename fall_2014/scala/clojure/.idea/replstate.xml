<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1418657722952">{:repl-history {:ide [], :local [&quot;(def w {:q 3 :r 5})&quot; &quot;(:q w)&quot; &quot;(:r w)&quot; &quot;(w :r)&quot; &quot;  (&lt; 3)&quot; &quot;  (&lt; 3 4\n     )&quot; &quot;  (&lt; 3 2)&quot; &quot;#(&lt;= % 1)&quot; &quot;(go 3)&quot; &quot;(factorial.go)&quot; &quot;(use factorial)&quot; &quot;(defn go [x] (* x 2))&quot; &quot;(&lt; 3 3)&quot; &quot;(defmulti factorial #(&lt;= % 1))&quot; &quot;(use 'factorial :reload)&quot; &quot;(factorial 5)&quot; &quot;(factorial 2)&quot; &quot;(factorial 1)&quot; &quot;(factorial 4)&quot; &quot;(factorial 3)&quot; &quot;(defn f ([x] x) ([x y] (* x y)))&quot; &quot;(f 4)&quot; &quot;(f 4 3)&quot; &quot;(or 4 5 6)&quot; &quot;(or true)&quot; &quot;(some? 4)&quot; &quot;(defmacro my-or\n   ([] nil)\n   ([x] x))&quot; &quot;(my-or 4)&quot; &quot;(macroexpand '(my-or 4))&quot; &quot;(macroexpand '(my-or s))&quot; &quot;(defmacro my-or\n   ([] nil)\n   ([x] x)\n   ([x &amp; next]\n     `(if ~x ~x (my-or ~next))))&quot; &quot;(macroexpand-1 '(my-or s r))&quot; &quot;(macroexpand-all '(my-or s r))&quot; &quot;(macroexpand '(my-or s r))&quot; &quot;(my-or false 5)&quot; &quot;(if true 5 0)&quot; &quot;(if false 4 (5))&quot; &quot;(if false 4 5)&quot; &quot;(if false 4 (if true 5 2))&quot; &quot;(or)&quot; &quot;(or 4)&quot; &quot;(defmacro my-or\n   ([] nil)\n   ([x] x)\n   ([x &amp; next]\n     `(if ~x ~x (~my-or ~next))))&quot; &quot;(defmacro my-or\n   ([] nil)\n   ([x] x)\n   ([x &amp; next]\n     `(if ~x ~x ~(my-or next))))&quot; &quot;(macroexpand '(my-or 4 1))&quot; &quot;(defmacro my-or\n   ([] nil)\n   ([x] x)\n   ([x &amp; next]\n     `(if ~x ~x (my-or ~@next))))&quot; &quot;(macroexpand '(my-or 4 1\n                     ))&quot; &quot;(or 4 5)&quot; &quot;(or 2 5)&quot; &quot;(or false 5)&quot; &quot;(or false false\n    )&quot; &quot;(or false)&quot; &quot;(or false false)&quot; &quot;(or 0 )&quot; &quot;(or 0 0 4 0 false )&quot; &quot;(or 0 0 4 0 false)&quot; &quot;(or false 4 0 false)&quot; &quot;(take-nth 2 [1 2 3 4 5 6 7 8])&quot; &quot;(take-nth 2 (rest [ 3 5 4 2 1 23]) )&quot; &quot;names&quot; &quot;(fn [x t] (* x t))&quot; &quot;(defmacro my-let\n   [bindings &amp; body]\n   (let [names (take-nth 2 bindings)\n         vals (take-nth 2 (rest bindings))]\n     `((fn [~@names] (do ~@body)) ~@vals) ))&quot; &quot;(my-let [x 5] (+ x 4))&quot; &quot;(\n  my-let [x 5] (+ x 4))&quot; &quot;(macroexpand '(my-let [x 5] (+ x 4)))&quot; &quot;(macroexpand '(my-let [x 5 y x] (+ x 4)))&quot; &quot;(let [x 4 y x] y)&quot; &quot;(defmacro my-let-1\n   [bindings &amp; body]\n   (let [names (take-nth 2 bindings)\n         vals (take-nth 2 (rest bindings))]\n     `((fn [~@names] (do ~@body)) ~@vals) ))&quot; &quot;(partition 2 [3 4 1 2])&quot; &quot;(partition 2 [3 4 1 2 3 4])&quot; &quot;(partition 2 [3 4 1 2 3 4 1])&quot; &quot;(reduce (fn [s (x y)] (+ s x y)) 0 (partition 2 [3 4 2 1]))&quot; &quot;(reduce (fn [s [x y]] (+ s x y)) 0 (partition 2 [3 4 2 1]))&quot; &quot;(defmacro my-let\n   [bindings &amp; body]\n   (let [params (partition 2 bindings)\n         wrap (fn [body [name val]] `((fn [~name] ~body) ~val))]\n     reduce wrap `(do ~@body) (reverse params) ))&quot; &quot;(macroexpand '(my-let [x 3] x))&quot; &quot;(reduce (fn [a x] a) 2 [3])&quot; &quot;partition 2 [x 3]&quot; &quot;(partition 2 [x 3])&quot; &quot;(partition 2 [3 3])&quot; &quot;(defmacro my-let\n   [bindings &amp; body]\n   (let [params (partition 2 bindings)\n         wrap (fn [body [name val]] `((fn [~name] ~body) ~val))]\n     (reduce wrap `(do ~@body) (reverse params)) ))&quot; &quot;(macroexpand '(my-let [x 3] x\n                      ))&quot; &quot;(my-let [x 3] x)&quot; &quot;(my-let [x 3 y x] y)&quot; &quot;(macroexpand '(my-let [x 4 y x z 42] (+ y z)))&quot; &quot;((my-let [x 4 y x z 42] (+ y z)))&quot; &quot;my-let [x 4 y x z 42] (+ y z)&quot; &quot;(my-let [x 4 y x z 42] (+ y z))&quot;], :remote []}}</component>
</project>

