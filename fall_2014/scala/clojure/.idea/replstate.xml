<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1419017191379">{:repl-history {:ide [], :local [&quot;(macroexpand-all '(my-or s r))&quot; &quot;(macroexpand '(my-or s r))&quot; &quot;(my-or false 5)&quot; &quot;(if true 5 0)&quot; &quot;(if false 4 (5))&quot; &quot;(if false 4 5)&quot; &quot;(if false 4 (if true 5 2))&quot; &quot;(or)&quot; &quot;(or 4)&quot; &quot;(defmacro my-or\n   ([] nil)\n   ([x] x)\n   ([x &amp; next]\n     `(if ~x ~x (~my-or ~next))))&quot; &quot;(defmacro my-or\n   ([] nil)\n   ([x] x)\n   ([x &amp; next]\n     `(if ~x ~x ~(my-or next))))&quot; &quot;(macroexpand '(my-or 4 1))&quot; &quot;(defmacro my-or\n   ([] nil)\n   ([x] x)\n   ([x &amp; next]\n     `(if ~x ~x (my-or ~@next))))&quot; &quot;(macroexpand '(my-or 4 1\n                     ))&quot; &quot;(or 4 5)&quot; &quot;(or 2 5)&quot; &quot;(or false 5)&quot; &quot;(or false false\n    )&quot; &quot;(or false)&quot; &quot;(or false false)&quot; &quot;(or 0 )&quot; &quot;(or 0 0 4 0 false )&quot; &quot;(or 0 0 4 0 false)&quot; &quot;(or false 4 0 false)&quot; &quot;(take-nth 2 [1 2 3 4 5 6 7 8])&quot; &quot;(take-nth 2 (rest [ 3 5 4 2 1 23]) )&quot; &quot;names&quot; &quot;(fn [x t] (* x t))&quot; &quot;(defmacro my-let\n   [bindings &amp; body]\n   (let [names (take-nth 2 bindings)\n         vals (take-nth 2 (rest bindings))]\n     `((fn [~@names] (do ~@body)) ~@vals) ))&quot; &quot;(my-let [x 5] (+ x 4))&quot; &quot;(\n  my-let [x 5] (+ x 4))&quot; &quot;(macroexpand '(my-let [x 5] (+ x 4)))&quot; &quot;(macroexpand '(my-let [x 5 y x] (+ x 4)))&quot; &quot;(let [x 4 y x] y)&quot; &quot;(defmacro my-let-1\n   [bindings &amp; body]\n   (let [names (take-nth 2 bindings)\n         vals (take-nth 2 (rest bindings))]\n     `((fn [~@names] (do ~@body)) ~@vals) ))&quot; &quot;(partition 2 [3 4 1 2])&quot; &quot;(partition 2 [3 4 1 2 3 4])&quot; &quot;(partition 2 [3 4 1 2 3 4 1])&quot; &quot;(reduce (fn [s (x y)] (+ s x y)) 0 (partition 2 [3 4 2 1]))&quot; &quot;(reduce (fn [s [x y]] (+ s x y)) 0 (partition 2 [3 4 2 1]))&quot; &quot;(defmacro my-let\n   [bindings &amp; body]\n   (let [params (partition 2 bindings)\n         wrap (fn [body [name val]] `((fn [~name] ~body) ~val))]\n     reduce wrap `(do ~@body) (reverse params) ))&quot; &quot;(macroexpand '(my-let [x 3] x))&quot; &quot;(reduce (fn [a x] a) 2 [3])&quot; &quot;partition 2 [x 3]&quot; &quot;(partition 2 [x 3])&quot; &quot;(partition 2 [3 3])&quot; &quot;(defmacro my-let\n   [bindings &amp; body]\n   (let [params (partition 2 bindings)\n         wrap (fn [body [name val]] `((fn [~name] ~body) ~val))]\n     (reduce wrap `(do ~@body) (reverse params)) ))&quot; &quot;(macroexpand '(my-let [x 3] x\n                      ))&quot; &quot;(my-let [x 3] x)&quot; &quot;(my-let [x 3 y x] y)&quot; &quot;(macroexpand '(my-let [x 4 y x z 42] (+ y z)))&quot; &quot;((my-let [x 4 y x z 42] (+ y z)))&quot; &quot;my-let [x 4 y x z 42] (+ y z)&quot; &quot;(my-let [x 4 y x z 42] (+ y z))&quot; &quot;(mod 345 2\n    \n     )&quot; &quot;(mod 342 2)&quot; &quot;(every? [nil true])&quot; &quot;(every? some? [nil true])&quot; &quot;(every? some? [4 true])&quot; &quot;(range 2 5)&quot; &quot;(range 2 3)&quot; &quot;(defn prime? [x]\n   (some #(mod x %) (range 2 x)))&quot; &quot;(prime? 12)&quot; &quot;some? (prime? 12)&quot; &quot;(some? (prime? 12))&quot; &quot;(defn prime? [x]\n   (some #(= 0 (mod x %)) (range 2 x)))&quot; &quot;(defn prime? [x]\n   (every? #(not= 0 (mod x %)) (range 2 x)))&quot; &quot;(prime? 5)&quot; &quot;(prime? 4)&quot; &quot;(prime? 1)&quot; &quot;(prime? 3)&quot; &quot;(prime? 16)&quot; &quot;(prime? 27)&quot; &quot;(defn allprime? [x] (every? prime? s))&quot; &quot;(defn allprime? [x] (every? prime? x))&quot; &quot;(allprime? [4 3 2 ])&quot; &quot;(allprime? [2 3 5 7])&quot; &quot;(defn fact\n   ([n acc]\n     (if (&lt;= n 1) acc (recur (- n 1) (* acc n))))\n   ([n] (fact n 1)))&quot; &quot;(fact 5)&quot; &quot;(defmacro with-a [body] `(let [~'a 0] ~@body))&quot; &quot;(with-a (println a))&quot; &quot;(defmacro with-a [&amp; body] `(let [~'a 0] ~@body))&quot; &quot;(with-a (println (+ a 1)) (println a))&quot; &quot;(range 3 10)&quot; &quot;(rand-int 34\n          )&quot; &quot;(def accounts (reduce (fn [m i]\n                        (assoc m i (ref 100)))\n                      {}\n                      (range 5)))&quot; &quot;accounts&quot; &quot;(accounts 2)&quot; &quot;(accounts 4)&quot; &quot;(defn transfer [from_id to_id amount]\n   (dosync\n     (alter (accounts from_id) - amount)\n     (alter (accounts to_id) + amount)))&quot; &quot;(transfer 0 1 5)&quot; &quot;(deref (accounts 1))&quot; &quot;(deref (accounts 0))&quot; &quot;(mod 3 2\n     )&quot; &quot;(vals accounts\n      )&quot; &quot;(import '(java.util.concurrent Executors))&quot; &quot;(defn test-transfer [iterations]\n   (let [pool (Executors/newFixedThreadPool 4)\n         tasks (map (fn [id]\n                      (fn []\n                        (dotimes [n iterations]\n                          (transfer id\n                                    (+ 1 id)\n                                    (+ id 5)))))\n                    (range 4))]\n     (doseq [future (.invokeAll pool tasks)]\n       (.get future))\n     (.shutdown pool)))&quot; &quot;(test-transfer 1)&quot; &quot;(test-transfer 100)&quot; &quot;(apply #(println (deref %)) (vals accounts))&quot; &quot;(apply println (vals accounts))&quot;], :remote []}}</component>
</project>

