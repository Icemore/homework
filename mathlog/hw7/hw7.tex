\documentclass[10pt]{article}
\usepackage[a4paper,margin=0.5cm]{geometry}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumerate}

\begin{document}

\title{Домашняя работа 7}
\author{Антон Афанасьев}
\maketitle

\begin{enumerate}

\item[2] Множество многочленов с целыми коэффициентами степени $n$ счетно, так как его можно рассматривать как совокупность $n$ счетных множеств. Множество всех многочленов с целыми коэффициентами счетно, так как оно является объединением счетного числа счетных множеств --- многочленов со степенями $0, 1, 2, \ldots$. У многочлена степени $n$ не более $n$ корней, а значит множество алгебраических чисел --- объединение счетного числа конечных множеств, а значит, оно является счетным множеством.

\item[3] 
\begin{enumerate}
	\item 
	\begin{itemize}
	
	\item $A \cup B$ --- перечислимо.
	
	 $A$ и $B$ --- перечислимы, а значит полуразрешимы. Возьмем полуразрешающие алгоритмы и, для некоторого входа, будем исполнять их параллельно (пошагово). Если вход принадлежит $A$ или $B$, то один из них завершится, тогда завершаем общий алгоритм. Получили полуразрешающий алгоритм для $A \cup B$, а значит это множество перечислимо.
	
	\item $A \cap B$ --- перечислимо.
	
	 Поступим так же, как в предыдущем случае, только будем останавливать алгоритм, когда оба полуразрешающих алгоритма завершаться.
	 
	\item $A \times B$ --- перечислимо.
	
	Возьмем пришедшую на вход пару, и запустим полуразрешающий алгоритм для $A$ на первом элементе и для $B$ на втором. Получим полуразрешающий алгоритм для $A \times B$, а значит, это множество перечислимо.
	
	\item $\bar A$ --- неизвестно.
	
	Если бы $\bar A$ было бы перечислимо, то, по теореме Поста, $A$ было бы разрешимо, но об этом ничего не сказанно.
	
	\item $f(A)$ --- перечислимо.
	
	Запустим перечисляющий алгоритм для $A$ и будем применять к тому, что он возвращает функцию $f$. Так мы перечислим $f(A)$.
	
	\item $f^{-1}(A)$ --- перечислимо.
	
	Построим график зависимости числа шагов полуразрешимого алгоритма для $A$ от числа $f(x)$. Обходя координатную сетку по диагоналям (как в доказательстве об эквивалентности полуразрешимого множества перечислимому) получим перечисляющий алгоритм	.	
	\end{itemize}
	
	\item Например, если множество $I$ перечислимо, то для входа $x$ можно записать график числа шагов полуразрешающих алгоритмов для $A_i$ на этом входе и обойти его по диагоналям. Если в какой-то момент один из алгоритмов завершится, то $x$ принадлежит объединению $A_i$. Получили полуразрешающий алгоритм для объединения, значит это множество перечислимо.
	
	Если добавить еще условия на разрешимость $A_i$, то можно просто проверять $x$ на принадлежность каждому из $A_i$ по очереди, это также будет полуразрешающий алгоритм для объединения.
	\end{enumerate}
	
	\item[4] Это множество полуразрешимо, так как для каждого конкретного $n$ можно перебрать все $x,\ y,\ z$ и проверить выполняется ли равенство. Чтобы перебор действительно обошел все значения будем перебирать их в особом порядке, например сначала тройки содержащие числа $\leq 1$ по модулю и содержащие 1, потом $\leq 2$ по модулю, и содержащие 2 и т.д. Множество полуразрешимо, следовательно оно перечислимо.
	
	\item[6] Будем строить приближения числа $\pi$ рациональными числами. Если число которое пришло на вход левее левой границы, то оно точно меньше $\pi$, если оно правее правой, то оно точно больше. Если число попадает в интервал, то увеличим точность приближения. Так как $\pi$ --- иррациональное число мы никогда не сойдемся, но увеличивать точность можем сколь угодно долго. Значит, для конкретного числа мы рано или поздно достигнем необходимой точности.
	
	\item[7] Возьмем перечисляющий алгоритм для нашего множества. Рассмотрим элементы множества в том порядке, в котором их выдает алгоритм. Возьмем те элементы множества которые выдаются в возрастающем порядке. То есть возьмем первый, потом возьмем тот, что будет больше первого, и т.д. на каждом шаге, если элемент больше текущего, то берем его и делаем его текущим. Эти элементы и будут разрешимым подмоножеством. Это подмножество бесконечно, так как в исходном бесконечном множестве для каждого конкретного конечного элемента найдется бесконечное число элементов больше него.
	
	Это подмножество разрешимо, так как можно составить такой разрешающий алгоритм: запустим перечисляющий алгоритм для исходного множества, и будем выбирать текущий элемент так же как при построении подмножества. Тогда, если элемент принадлежит подмножеству, то он встретится среди текущих, а если нет, то мы остановимся, когда текущий элемент станет больше искомого.

\end{enumerate}
\end{document}