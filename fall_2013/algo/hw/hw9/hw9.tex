\documentclass[10pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage[margin=2cm]{geometry}
\usepackage{pseudocode}

\begin{document}

\title{Домашняя работа 9}
\author{Антон Афанасьев}
\maketitle

\begin{enumerate}

\item Подсчитаем по дереву $T$ расстояния $d_v$ от вершины $s$ до всех остальных. Теперь попробуем каждым ребром графа $G$ порелаксировать эти расстояния. Для ребра $(u, v)$ с весом $w(u, v)$, если $d_v > d_u + w(u, v)$, то до $d_v$ есть более короткий путь, который проходит через $u$, а значит $T$ не является деревом кратчайших путей. 

Пусть не нашлось такого ребра, то есть для всех ребер $(u, v)$ выполняется $d_v \le d_u + w(u, v)$. Тогда длины путей $d_v$ минимальные и дерево $T$ является деревом кратчайших путей. Докажем это. Пусть $\hat d_v$ --- оптимальные веса. Тогда, для каждой пары вершин $u,\ v$, таких, что между ними есть ребро, и $\hat d_v = \hat d_u + w(u, v)$, если $d_u = \hat d_u$, то $d_v = \hat d_v$. Это следует из того, что $d_v \le d_u + w(u, v) \Rightarrow d_v \le \hat d_u + w(u, v) \Rightarrow d_v \le \hat d_v$ и $d_v \ge \hat d_v$. Так как для стартовой вершины $d_s = \hat d_s$, то, по индукции, для всех $d_v = \hat d_v$. Что и требовалось доказать.

\item Мы разбирали эту задачу на практике. В поиске в ширину подсчитываем количество кратчайших путей для каждой вершины как сумму количества путей в уже посещенные соседние вершины, находящиеся на предыдущем уровне поиска в ширину.

\item Для каждой пары вершин $u, v$ кратчайший путь между ними, проходящий через $s$, состоит из двух частей, и выглядит как $u \leadsto s \leadsto v$. Каждая из частей должна быть кратчайшим путем (иначе весь путь не будет кратчайшим). Ответ на задачу --- сумма этих двух путей. Найдем алгоритмом Дейкстры кратчайшие пути из $s$ во все вершины, это будет вторая часть ответа. Найдем первую часть (пути из всех вершин в $s$), запустив алгоритм Дейкстры из вершины $s$ на транспонированном графу (у всех ребер меняется направление на противоположное).

Для разреженных графов ($E=O(V)$) будем использовать алгоритм Дейкстры с кучей, трудоемкость $O((|V| + |E|) \log |V|)$. Для плотных графов будем использовать алгоритм с массивом, трудоемкость $O(|V|^2)$.

\item Будем находить пути алгоритмом Дейкстры, только при обновлении текущих расстояний до вершин будем использовать нужные метрики. Так как добавление ребра к пути не может уменьшить вес пути по таким метрикам, алгоритм Дейкстры будет корректным.

\end{enumerate}
\end{document}
