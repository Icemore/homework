\documentclass[10pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage[margin=2cm]{geometry}
\usepackage{pseudocode}

\begin{document}

\title{Домашняя работа 8}
\author{Антон Афанасьев}
\maketitle

\begin{enumerate}
\item Построим граф состояний. Состояние --- номер клетки, в которой стоит кубик и его ориентация (можно задать ее например нижней и левой гранями). Переход между состояниями --- перекатывание по ребру в не черную клетку с соответствующим изменением положения. Из каждого состояния не более 4-х переходов.

\item Построим граф состояний. Состояние --- клетка и текущий уровень воды (не больше высоты клетки). Переход --- между двумя соседними клетками, уровень воды поднимается на $1+|h_1 - h_2|$, если уровень превышает $h_2$ то ребро не проводим (некуда). Если из начального состояния есть путь в любое состояние, соответствующее клетке $(n, m)$, то у туриста получится добраться в конечную клетку указанным способом. Минимальное время равно минимальному уровню воды у достижимого состояния с клеткой $(n, m)$.

Вершин $O(nmh)$, переходов из каждой вершины не более 4.

\item Заметим, что если получается добраться во все аэропорты с баком размера $w$, то и с баком большего размера добраться получится. А если с баком размера $w$ добраться не удается, то с баком меньшего размера добраться точно не получится.

Будем делать бинпоиск по ответу (объем бака). Очевидно, что он лежит в пределах $[0, W]$. Для текущего размера бака выкинем все ребра с большим весом, чем текущий размер бака --- по ним нельзя пройти. По остальным ходить можно сколько угодно. Проверим, что такой граф является сильно связным. Если является, то с таким размером бака можно долететь из любого города в любой другой. Бинпоиском находим минимальный допустимый размер.

Трудоемкость : $O(n^2 \log W)$. $O(\log W)$ на бинпоиск, и $O(n^2)$ на  каждой итерации, т.к. в графе $O(n^2)$ вершин и ребер.

\item Мы разбирали эту задачу на практике. Одно из решений: заведем дек, будем делать поиск в ширину, только при обнаружении вершины кладем ее в начало дека, если мы пришли в нее по ребру веса 0, и в конец, если пришли по ребру веса 1. Берем вершины всегда из начала. Так мы переберем все вершины, достижимые из стартовой, в порядке неубывания расстояний от нее.

\item Назовем хорошую точку точкой сочленения. Пусть мы делаем поиск в глубину и находимся в вершине $v$. Заметим, что если ни из какого ее потомка в дереве поиска нет обратного ребра в какого-либо предка $v$, то $v$ является точкой сочленения. Исключение --- корневая вершина. Она будет являться точкой сочленения, только если у нее больше одного сына в дереве обхода (т.к. поддеревья достижимы друг из друга только через эту вершину). 

Для того чтобы проверять условие, что ни из какого ребенка нет ребра в потомка будем для каждой вершины запоминать время входа поиска в глубину $t_{in}$. Теперь в поиске в глубину будем для каждой вершины $v$ считать наименьшее время входа вершины, которая достижима из поддерева $v$ по обратному ребру. Обозначим эту величину как $d_v$, если вершины, достижимой по обратному ребру нет, $d_v = t_{in}(v)$. $d_v$ можно пересчитывать используя эти значения в детях. $d_v$ равно минимуму из времени входа в $v$, времен входа вершин, в которые есть обратное ребро из $v$ и значений $d$ в детях.

Если $d_v \ge t_{in}(v)$, то точка $v$ является точкой сочленения.

\item Назовем хорошие ребра мостами. Заметим, что если мы сейчас в поиске в глубину в вершине $v$ и из поддерева ее ребенка $u$ нет обратного ребра в какого-либо предка $v$, то ребро $(v, u)$ является мостом.

Подсчитаем значения $d_v$ точно такие же как в предыдущей задаче. Теперь ребро $(v, u)$ --- мост, если $d_u > t_{in}(v)$

\end{enumerate}
\end{document}
