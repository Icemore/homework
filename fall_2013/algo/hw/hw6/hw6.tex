\documentclass[10pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage[margin=2cm]{geometry}
\usepackage{pseudocode}

\begin{document}

\title{Домашняя работа 6}
\author{Антон Афанасьев}
\maketitle

\begin{enumerate}

	\item Пусть $h$ --- высота кучи, и $T(\text{INSERT}) \le c_1 \log n$, $T(\text{EXTRACT-MIN}) \le c_2 \log n$.\\
	Функция потенциалов --- $\Phi = c_2 \cdot n \cdot \log n$.\\
	$T'(\text{INSERT}) \le  c_1 \log n + c_2 n \log n - c_2  (n-1)  \log (n-1) = c_1 \log n + c_2 \log (n-1) + c_2 n (\log n - \log (n-1)) \Rightarrow T'(\text{INSERT})= O(\log n)$.\\
	$T'(\text{EXTRACT-MIN}) \le c_2 \log n + c_2 n \log n - c_2 (n+1) \log (n+1) = c_2 (\log n - \log (n+1)) + c_2 n (\log n - \log (n+1)) \Rightarrow  T'(\text{EXRACT-MIN})=O(1)$.\\
	Т.к. $\lim_{n \to \infty }(\log n - \log (n-1)) = \lim_{n \to \infty}( \log n - \log (n+1)) = 0$.
	
	\item Реализуем счетчики на деке (можно добавлять элементы в начало и в конец). Храним счетчик так, что первый элемент массива - младший бит. Тогда удвоение счетчика --- это просто добавление 0 в начало массива.\\
	Произведем анализ по методу банкира. Будем запасать в каждом ненулевом бите кредит, которым потом оплатим его зануление и ``перевод'' в другой счетчик посредством суммы. $C_{dep}$ --- значение вклада, $C_{loan}$ --- значение займа, $t$ --- количество единиц, которые нам придется занулить.\\
	$C_{dep}(inc) = 2$, $C_{loan}(inc) = t$\\
	$C_{dep}(sum) = 0$, $C_{loan}(double) = \min(len(C), len(C')) + t$.
	$C_{dep}(double) = 1$ и $C_{loan}(double)=0$\\
	Тогда $T'(inc) = O(1)$, $T'(sum) = O(1)$ и $T'(double)=O(1)$.\\
	Покажем, что условие банкира не нарушается. С каждой единицей можно связать вклад как минимум в 2 единицы, а с каждым значащим нулем как минимум в одну единицу. Если это условие не нарушается, то условие банкира тоже  не будет нарушаться, так как мы никогда не занимаем больше, чем количество значащих бит в числе.\\
	Пусть наше условие выполняется. Рассмотрим операцию inc. Она устанавливает один бит в 1 и запасает для него 2 единицы денег. При этом некоторое количество единиц зануляется и на это расходуется по одной монете, которые были в них запасены. Инвариант не нарушается.
	Рассмотрим операцию double. Она добавляет один ноль и запасает в нем 1. Инвариант не нарушается.\\
	Рассмотрим операцию суммы. Для всех значащих битов $C'$ она потратит запасенные в них деньги и, возможно, еще добавит единицу к какому-то разряду $C$. Добавление единицы к какому-то разряду будет действовать так же как просто инкремент, и инвариант не нарушится.\\
	Итак, операции не нарушают инвариант банкира, а значит амортизационные оценки верны.
	
	\item Найти k ближайших к медиане элементов в массиве за линейное время.\\
	\begin{enumerate}
		\item По позиции в отсортированном массиве\\
		k ближайших к медиане по позиции будут находиться в интервале $\left [ \lceil \frac{n}{2} \rceil  - \frac{k}{2} ; \lceil \frac{n}{2} \rceil + \frac{k}{2} \right]$ с округлениями в нужную сторону. Обозначим этот интервал как $[l; r]$. Найдем $l$ и $r$ порядковые статистики и произведем две операции Partition: сначала всего массива по $r$-той порядковой статистике, а потом $[1, r]$ по $l$-той. Таким образом в интервале $[l; r]$ окажутся элементы, которые будут там в отсортированном массиве. Порядковые статистики и Partition работают за $O(n)$, поэтому трудоемкость $O(n)$.
		\item По значению\\
		Заметим, что k ближайших к медиане по значению элементов в отсортированном массиве представляют отрезок, который содержит медиану.  Пусть $m = \lceil \frac{n}{2} \rceil$. Найдем медиану и $m-k$ и $m+k$ статистики и произведем разбиение относительно них. Будем искать границы нужного отрезка в интервалах $[m-k, m],\ [m, m+k]$.\\
		На каждой итерации будем производить следующие действия: в левом и правом отрезке возьмем середину --- $l$ и $r$. Разобьем левый отрезок $l-1$ и $l$ порядковыми статистиками, а правый $r$ и $r+1$. Это можно сделать за время пропорциональное длине отрезков. Рассмотрим отрезок $[l, r]$. Возможно его нужно подвинуть в какую-то сторону чтобы он стал искомым отрезком. Если выполняется неравенство $a[m] - a[l] > a[r+1] - a[m]$, то его нужно подвинуть вправо. Однако, это означает, что левая граница отрезка должна находится правее l, а правая правее r. Обратный случай выражается аналогично, неравенство для него: $a[m] - a[l-1] < a[r] - a[m]$. Таким образом мы на каждой итерации будем уменьшать размер отрезков в два раза, пока не сойдемся. Элементы находящиеся между правой и левой границами отрезка и будут ответом, так как мы каждый раз производили разбиение.\\
		Оценим трудоемкость. На каждой итерации выполнялось количество операций линейное от длины интервалов. Всего:\\
		$$c k + \frac{ck}{2} + \frac{ck}{4} ... \le ck \left ( \sum_{i=0}^\infty \frac{1}{2^i} \right) = 2ck$$
		С учетом еще изначальных разбиений и поиска медианы трудоемкость $O(n)$.
	\end{enumerate}
	
	\item Найти k-квантили множества за $O(n \log k)$.\\
	Запишем все индексы элементов в отсортированном массиве, которые являются k-квантилями в массив b. Алгоритм будет искать элементы с индексами от $b[l]$ до $b[r]$, причем на момент вызова функции элементы, которые в отсортированном массиве находятся в этом интервале должны там находиться. Изначально $l=1,\ r=k-1$ и условие очевидно выполняется.\\
	Алгоритмом поиска k-той порядковой статистики найдем элемент элемент с индексом b[(l+r)/2] и произведем разбиение по нему. Это делается за время, линейное относительно $b[r] - b[l]$. После чего запустим алгоритм рекурсивно на обеих половинах интервала.\\
	Рассмотрим этот алгоритм как дерево. Его высота $\log k$, и на каждом уровне происходит $n$ операций. Значит, трудоемкость алгоритма $O(n \log k)$.
	
	\item При запросе каждой страницы будем находить нужную порядковую статистику, делать по ней разбиение а потом просто сортировать посты внутри страницы за $O(k \log k)$. Но перед тем как искать порядковую статистику для страницы разобьем интервал в котором она находится на две части медианой. То есть для первой страницы сначала разобьем отрезок $[1, n]$ на $[1, n/2]$ и $[n/2+1, n]$ и будем искать статистику для страницы только в половине. Для второй страницы разобьем $[1, n/2]$ еще пополам (если она в него попадает) и т.д. Получается, что страница генерируется $O(n + k \log k)$. И при этом всего на разбиения будет потрачено операций:\\
	$n +2(\frac{n}{2} + 2(\frac{n}{4} \ldots )) = O(n \log n)$ (т. к. в такой сумме $\log n$ слагаемых.\\
	Общая трудоемкость $O(n \log n)$ на разбиения, плюс $O(n \log k)$ на сортировки, итого $O(n \log n)$.
\end{enumerate}
\end{document}
