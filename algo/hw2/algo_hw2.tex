\documentclass[10pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumerate}
\usepackage[margin=2cm]{geometry}

\begin{document}

\title{Домашняя работа 2}
\author{Антон Афанасьев}
\maketitle

\begin{itemize}

\item Скобочная последовательность 

В корректной скобочной последовательности всегда существует пара скобок которые стоят непосредственно друг за другом (самые ``внутренние'' скобки), причем если их удалить скобочная последовательность останется корректной. Будем по очереди удалять такие скобки, пока можем. Если в итоге ничего не останется, то скобочная последовательность была корректной.\\
Для этого используем стек. Идем по входной строке слева направо. Для каждого символа:
\begin{itemize}
\item Если это открывающая скобка просто кладем ее в стек.
\item Если это закрывающая скобка, то достаем из стека ей парную. Если стек пуст, или на его вершине скобка другого типа, скобочная последовательность нарушена.
\end{itemize}
Если после такого прохода стек пуст, то скобочная последовательность корректна.

\item Сумма на отрезке

Предподсчитаем частичные суммы на префиксах $C_i = \sum_{j=0}^i a_j$. Это можно сделать за линейное время, так как \\
$C_0=a_0$\\
$C_i = C_{i-1} + a_i$

Теперь можно отвечать на запрос за константу, т. к.
$$\sum_{i=l}^r a_i = C_r - C_{l-1}$$

\item Вычеркивание цифр\\
Дано число c цифрами $a_1, a_2, \ldots, a_n$.

Максимизируем первую цифру искомого числа, т.к. если она не будет наибольшей возможной, то все число не будет максимальной. На первое место можно поставить любую цифру из $a_1, \ldots, a_{k+1}$ (максимум можно вычекнуть первые $k$ цифр). Возьмем из них максимальную, а из них самую левую, пусть это будет $a_i$. Останется такая же задача меньшей размерности --- найти максимальное число, которое получится из $a_{i+1}, \ldots, a_n$ вычеркиванием $k-i+1$ цифр. Лидирующие нули нас здесь не волнуют, так как в качестве первой цифры мы его точно не выберем (выбираем максимальную цифру, нам гарантировали, что $a_1$ не 0), а остальные цифры ничего не испортят. \\
Осталось научиться делать это быстро. Заведем очередь с поддержкой операции максимум, которая умеет еще говорить индекс самого левого из максимумов (это легко реализовать храня в стеках на которых написана очередь не просто максимальный элемент, а пару из максимального элемента и индекса). Будем идти по $a_i$ слева направо и класть в очередь. Наберем первые $k+1$, спросим у очереди какой из них максимальный. Пусть это $a_i$. Запишем $a_i$ в ответ, вытащим из очереди первые $i$ элементов, добавим один следующий. Спросим у очереди максимальный, добавим его к ответу, выкинем из очереди все до него включительно, добавим один.\\
Несложно видеть, что такие действия равносильны описанным в первом абзаце. Действительно, после того, как начало очереди сдвинется на $a_{i+1}$ элемент в очереди будет лежать $k-i+1$ элемент. Для решения подзадачи с вычеркиванием $k-i+1$ элементов нам нужно сдвинуть правый конец на 1 элемент вправо.

\item Последовательность $a_1, a_2, \ldots, a_n$ найти отрезок $[l, r]$ на котором $(r-l+1)\min_{i \in [l, r]} a_i$ максимально.

Зафиксируем $a_i$ в максимизируемом выражении. Тогда понятно, что нам выгодно раздвигать границы отрезка до тех пор, пока мы не упремся либо в края массива, либо в $a_j < a_i$, причем еще улучшить ответ мы для данного $i$ не сможем. Пусть знаем эти границы для каждого $a_i$, тогда можно просто перебрать их и найти ответ.\\
Предподсчитаем для каждого $a_i$ правую границу интервала - индекс первого элемента справа, который меньше $a_i$, или $n+1$ если такого элемента нет. Будем делать это следующим образом: \\
Заведем стек, куда будем складывать индексы. На каждой итерации в стеке лежат индексы $j$, элементов, для которых еще нет ответа, в неубывающем (по значению $a_j$) порядке. Пойдем по массиву слева направо. Пусть мы сейчас на позиции $i$. Вытащим из стека все $j$ такие, что $a_j > a_i$. Для них $i$ будет ответом (первый справа элемент, который меньше). Положим $i$ в стек и продолжим. После того как дойдем до конца, для всех индексов оставшихся в стеке ответ -- $n+1$, т. к. для них не нашлось элемента справа который был бы меньше их.\\
Такой подход корректен, так как получается, что индексы хранятся в стеке по неубыванию элементов, и первый же элемент который будет меньше $a_i$ вытолкнет его из стека. Каждый элемент один раз зайдет в стек и один раз выйдет, поэтому этот алгоритм работает за линейное время.\\
Проведем такую же операцию в справа налево, чтобы найти левые границы оптимального интервала для каждого элемента. После этого переберем $a_i$ и найдем ответ.

\end{itemize}

\end{document}
