\documentclass[10pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage[margin=2cm]{geometry}

\begin{document}

\title{Домашняя работа 4}
\author{Антон Афанасьев}
\maketitle

\begin{enumerate}
	\item Сортировка $n$ патронов, каждый из которых отклонился от своей позиции не более чем на $k$.
	
	\begin{itemize}
		\item Алгоритм за $O(nk)$\\
		Выберем из первых $k$ элементов минимальный, поставим его на первое место (поменяем с первым); выберем из вторых $k$ элементов минимальный, поставим его на второе место и т.д. Эти действия не нарушают условия ``отклонятся не более чем на $k$'', т.к. на каждом шаге изменяются позиции двух элементов --- один возвращается на свою позицию, а второй перемещается не более чем на $k$ вправо. Т.к. исходная позиция второго элемента тоже была справа, то условие для него не нарушилось.
		\item Алгоритм за $O(n+I)$, $I$ -- число инверсий.\\
		Алгоритм сортировки вставками будет работать за такое время.\\
		На каждой итерации поддерживается инвариант ``префикс длины $i$ отсортирован''. $i$-тый элемент протаскивается влево так, чтобы инвариант сохранялся. При каждом обмене устраняется одна инверсия.
		
		\item Нижняя оценка $\Omega(n \log k)$ \\
		Рассмотрим дерево решений для алгоритма сортировки такого массива. Оценим число листьев $L$ у такого дерева, это --- число возможных перестановок, для которых выполняется условие на отклонение элемента от своего места. Построим следующий массив - для $i$-ого места, если этот элемент еще не менялся, выберем элемент из следующих $k$ и поменяем местами с $i$. Условие ``если элемент еще не менялся'' нужно для того, чтобы не дать значению ``уйти'' дальше чем на $k$ направо. Для последних $k$ элементов таких ограничений нет. Очевидно, что подобные массивы будут удовлетворять условию и при этом их меньше чем всех. Их количество можно грубо оценить как\\
		$$L > k^{\frac{n-k}{2}} \cdot k!$$
		А значит высоту дерева решений можно оценить как
		$$h \ge \log(L) \ge \frac{n}{2} \log k - \frac{k}{2} \log k + \log (k!) = \Omega(n \log k)$$

		\item Алгоритм за $O(n \log k)$\\
		Будем делать то же, что в алгоритме за $O(nk)$, только будем находить минимум не за $O(k)$, а за $O(\log k)$. Для этого используем кучу. Положим первые $k$ элементов в кучу. На каждом шаге сдвигаем интервал в котором находятся кандидаты на один вправо (вытаскиваем минимум из кучи и добавляем следующий, если он есть).
	\end{itemize}
	
	\item $2 \cdot n -1 $ коробок с черными и белыми шарами. Выбрать $n$ так, чтобы суммарное число черных и белых было не меньше половины. \\
	Отсортируем массив по не возрастанию числа белых шаров. Будем считать, что мы взяли в ответ коробки $a_1, a_3, a_5, \ldots, a_{2\cdot n -1 }$. Заметим, что $w_{a_1} \ge w_{a_2},\ w_{a_3} \ge w_{a_4},\ \ldots\  w_{a_{2\cdot n-3}} \ge w_{a_{2\cdot n-2}}$, а значит сумма всех выбранных белых шаров не меньше половины.\\
	Теперь рассмотрим пары $(a_2,\ a_3),\ (a_4,\ a_5),\ \ldots,\ (a_{2\cdot n -2}, a_{2\cdot n -1})$. В каждой такой паре сейчас в ответ взята вторая коробка, однако выбор можно изменить на первую и это не испортит сумму белых шаров, так как она не уменьшится. То есть можно выбрать любую из двух коробок в каждой паре.\\
	Теперь в каждой паре $(a_2,\ a_3),\ (a_4,\ a_5),\ \ldots,\ (a_{2\cdot n -2}, a_{2\cdot n -1})$ возьмем в ответ ту коробку, в которой больше число черных шаров. Таким образом (с учетом еще того, что коробка $a_1$ тоже входит в ответ) мы получим сумму черных шаров не меньше половины и не испортим при этом сумму белых шаров.\\
	Трудоемкость --- $O(n \log n)$ на сортировку.
	
	\item Построить самую сложную кучу для сортировки.\\
	Для наибольшего числа вызовов \texttt{heapifyDown} нужно, чтобы последний элемент каждый раз спускался до листа. Построим такую кучу, у которой наименьший элемент после каждой итерации сортировки --- последний. Очевидно, что такая куча будет наихудшей, так как наименьший элемент всегда придется спускать до листа. Будем считать, что куча размера $n$ построена на элементах от $1$ до $n$.\\
	Пусть у нас есть куча размера $n-1$, обладающая таким свойством. Добавим к ней элемент $n$ следующим образом --- изменим последний элемент на $n$, вызовем для него \texttt{heapifyUp} (при этом он поднимется с листа до корня), увеличим размер кучи на 1, присвоим последнему элементу 1. Очевидно, что при этом получается корректная куча. Покажем, что для нее сохраняется свойство.\\
	На первой итерации алгоритма сортировки наименьший элемент становится первым и для него вызывается \texttt{heapifyDown}. Можно видеть, что он пройдет такой же путь вниз до листа (обратный), каким шел элемент $n$ при построении кучи. Куча размера $n-1$ при этом вернется к изначальному состоянию (на каждом шаге \texttt{heapifyDown} будет выбирать из трех элементов наибольший --- это будет элемент который стоял на этом месте в изначальной куче).\\
	Значит, мы получили кучу размера $n$, у которой последний элемент на каждой итерации алгоритма --- последний. Сложность алгоритма --- $O(n \log n)$.
	
	\item Персистентный список.\\
	Реализуем однонаправленный связный список на объектах. В качестве ``версии'' храним указатель на начало и текущий указатель. Операции begin, next, at такие же как в обычном списке, затрагивают только текущий указатель. Для вставки и удаления будем копировать все начало списка до вставляемого или удаляемого элемента, в новую версию запишем новый указатель на начало.
	
\end{enumerate}
\end{document}
