\documentclass[10pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage[margin=2cm]{geometry}
\usepackage{pseudocode}

\begin{document}

\title{Домашняя работа 5}
\author{Антон Афанасьев}
\maketitle

\begin{enumerate}
	\item Наихудший случай для быстрой сортировки.\\
	Будем считать, что элементы массива -- различные числа от 1 до $n$. Пусть у нас есть массив, в котором на каждом шаге сортировки на месте $\left \lceil \frac{n}{2} \right \rceil$ стоит наибольший элемент. Тогда на каждом шаге сортировка будет рекурсивно запускаться на массиве размера $n-1$ и общая сумма будет квадратичной.\\
	Рассмотрим переход от массива размера $n$ к массиву размера $n-1$. При удалении элемента $a_{\left \lceil \frac{n}{2} \right \rceil}= n$ элементы массива, которые были правее, сдвинулись на один влево.\\
	Пусть $n$ - четное. Тогда $\left \lceil \frac{n}{2} \right \rceil = \left \lceil \frac{n-1}{2} \right \rceil$, а значит, элемент со значением $n-1$ находился справа от элемента $\left \lceil \frac{n}{2} \right \rceil$ в изначальном массиве.\\
	Пусть $n$ - нечетное. Тогда $\left \lceil \frac{n}{2} \right \rceil = \left \lceil \frac{n-1}{2} \right \rceil + 1$, а значит, элемент со значением $n-1$ находился слева от элемента $\left \lceil \frac{n}{2} \right \rceil$ в изначальном массиве.\\
	Таким образом, получается, что нужно расставлять элементы по убыванию начиная с середины, чередуя добавление налево и направо. Более просто можно сделать то же самое двумя циклами:\\
	$\FOR i \GETS 1 \TO \left \lfloor \frac{n}{2} \right \rfloor \DO
		a[i] \GETS 2*i;
	$
	
	$\FOR i \GETS n \TO \left \lfloor \frac{n}{2} \right \rfloor+1 \DO
		a[i] \GETS 2*(n-i)+1;
	$
	
	\item Поиск в унимодальном массиве.
	\begin{enumerate}
		\item Будем искать пик бинарным поиском. Для каждого элемента мы можем сказать относися он к ``возрастающей'' части или к ``убывающей'' сравнив его со следующим или предыдущим, а значит для каждого элемена можем сказать слева или справа от него находится пик. На каждом шаге бинарного поиска будем выбирать ту половину в которой находится пик.
	\end{enumerate}
	
	\item Отсортируем точки $p_i$ по возрастанию.\\
	Пусть $q$ находится в интервале от $p_m$ до $p_{m+1}$. В этом интервале оптимизируемая функция равна
	$$\sum_{i=1}^{m} w_i(q-p_i) + \sum_{i=m+1}^n w_i (p_i - q)$$
	Изменим $q$ на некоторое $\delta$. Значение оптимизируемой функции изменится следующим образом:
	$$\sum_{i=1}^{m} w_i(q+\delta-p_i) + \sum_{i=m+1}^n w_i (p_i - q-\delta) = \sum_{i=1}^{m} w_i(q-p_i) + \sum_{i=m+1}^n w_i (p_i - q) + \delta \left( \sum_{i=1}^m w_i - \sum_{i=m+1}^n w_i \right)$$
	Где множитель при $\delta$ -- константа в данном интервале. То есть функция в каждом интервале монотонно убывает или возрастает, а значит в качестве $q$ выгодно брать одну из точек $p_i$.\\
	Научимся делать это за один проход. Пусть мы знаем значение оптимизируемой функции, для случая кодга $q = p_m$; обозначим его как $D_m$.
	$$D_m = \sum_{i=1}^{m-1} w_i(p_m-p_i) + \sum_{i=m+1}^n w_i (p_i - p_m)$$
	$$D_{m+1} = D_m - p_m \sum_{i=1}^{m-1}w_i - p_m \cdot w_m + p_{m+1} \sum_{i=1}^{m} w_i + p_m \sum_{i=m+1}^n w_i - p_{m+1} \sum_{i=m+2}^n w_i - p_{m+1} \cdot w_{m+1}$$
	$$D_{m+1} = D_m +(p_{m+1} - p_m) \sum_{i=1}^m w_i + (p_m - p_{m+1}) \sum_{i=m+1}^n w_i$$
	Суммы префикса и суфикса массива можно просто хранить и пересчитывать за константу, тогда переход будет выполняться за константу. На то, чтобы в первый раз подсчитать значение функции и суммы потребуется $O(n)$ времени.\\
	Итого, получили алгоритм за $O(n \log n)$ за счет сортировки.
	
	\item[5.] Будем идти по массиву слева на право и поддерживать 3 области с элементами одного вида: $[1, i-1]$ -- элементы первого вида, $[b+1, c]$ -- второго и $[c+1, n]$ третьего. Соответственно будем поддерживать три индекса: $i$ -- указатель на текущий элемент (про него еще ничего не известно), $b$ и $c$ -- указатели на элемент перед началом области с элементами двух последних видов. Обрабатываем элементы слудующим образом:\\
	$\IF a[i]=\text{``капуста''} \THEN i \GETS i+1
	\ELSEIF a[i]=\text{``мясо''} \THEN \BEGIN swap(a, i, b)\\ b \GETS b-1 \END
	\ELSEIF a[i]=\text{``повидло''} \THEN \BEGIN
		swap(a, b, c)\\
		b \GETS b-1 \\
		swap(a, i, c)\\
		c \GETS c-1
	\END$\\
	Где функция swap(a, i, j) меняет местами элементы массива a с индексами i и j.\\
	Начальные значения индексов: $a=1,\ b=c=n$.\\
	Такие преобразования сохраняют инвариант, при этом на каждом шаге элемент $a[i]$ ``надкусывается'' и отправлется в нужную группу. Количество неопределенных элементов уменьшается на 1. За $n$ шагов массив будет упорядочен как требовалось.
\end{enumerate}
\end{document}
