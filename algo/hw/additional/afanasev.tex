\documentclass[10pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage[margin=2cm]{geometry}
\usepackage{pseudocode}

\begin{document}

\title{}
\author{Антон Афанасьев}
\maketitle

\begin{enumerate}
\item[10] Пусть для вершины $v$ $closest(v) = dist(u, v)$ и кратчайший путь от $u$ до $v$ --- это $u=x_1, x_2, x_3, \ldots, x_k=v$. Тогда, $closest(v) = \omega(x_{k-1}, v) + closest(x_{k-1})$, так как если бы это было не так, то можно было бы заменить часть пути с $x_1$ до $x_{k-1}$ на ближайший путь до $x_{k-1}$ и общий вес бы уменьшился.
  
Проинициализируем $closest(v) = 0$. Будем пересчитывать их алгоритмом, напоминающим алгоритм Форда-Беллмана: $n-1$ раз перебираем все ребра и пытаемся улучшить ответ, то есть для ребра $(u, v)$ обновим $closest(v) = \min(closest(v), closest(u)+\omega(u, v))$.

Докажем корректность. После выполнения $i$ итераций алгоритма он находит все ``ближайшие'' пути длиной не более $i$ по ребрам. Докажем по индукции. Для $i=0$ --- выполняется. Пусть выполняется для $k-1$. На следующей итерации, для любого $v$, длина ``ближайшего'' пути до которого равна $k$, когда мы будем обрабатывать последнее ребро в этом пути $(u, v)$, то по формуле из первого абзаца длина ``ближайшего'' пути до $u$ равна $k-1$ и, по предположению индукции, уже подсчитана, и по той же формуле пересчет значения $closest(v) = closest(u)+\omega(u, v)$ дает правильное значение. Следовательно, инвариант сохраняется.

Так как длина любого пути по ребрам не может превышать $n-1$ в итоге алгоритм найдет все нужные длины путей.

\end{enumerate}

\end{document}
