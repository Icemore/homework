\documentclass[10pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage[margin=2cm]{geometry}
\usepackage{relsize}

\newcommand{\rchoose}[2]{\left(\mkern-6mu \left({#1 \atop #2}\right) \mkern-6mu \right)}
\newcommand{\dsum}{\sum_{\substack{ k\le n \\ k - \text{нечетное}}}}
\renewcommand{\P}{\text{Pr}}

\begin{document}

\title{Домашняя работа 11}
\author{Антон Афанасьев}
\maketitle

\begin{enumerate}
	\item[1.] Предподсчитаем полиномиальный хэш для каждого префикса $s$ за линейное время (как при подсчете частичных сумм) $H_0 = s_0 \mod p$, $H_k = H_{k-1} + x^k \cdot s_k \mod p$.
	
	Для ответа на запрос будем бинарным поиском по ответу искать первый несовпадающий символ в подстроках. Подстроки будем сравнивать на равенство при помощи хэшей. Хеш для подстроки $s[a..b]$ получим как $(H_b - H_{a-1}) / x^{a} \mod p$. Так как операции выполняются по модулю нам необходимо найти обратный к $x^a$, но так как это значение одинаково на всех итерациях бинарного поиска (начало строк не меняется), то достаточно его найти один раз для начала первой и второй запрошенной подстроки.
	
	 \item[2.] Сделаем бинпоиск по длине общей подстроки, будем искать максимальную. Очевидно, что если есть общая подстрока размера $k$, то и меньшего размера общие подстроки тоже есть, а если общей подстроки размера $k$ нет, то большего размера общей подстроки не может быть.
	 
	 Для фиксированной длины $k$ подсчитаем хэши всех подстрок длины $k$ строки $s$ и положим их в хэш-таблицу (вместе с индексами в качестве значений). Будем пересчитывать их как в алгоритме Рабина-Карпа, тогда это займет линейное время. Таким же образом подсчитаем хэши всех подстрок длины $k$ строки $t$ и проверим, есть ли они в хэш таблице (есть ли общие подстроки длины $k$).
	 
	 Итого, на каждой итерации бинпоиска $O(n)$ операций, всего $O(n \log n)$.
	
		
\end{enumerate}
\end{document}
