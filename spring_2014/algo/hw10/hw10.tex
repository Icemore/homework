\documentclass[10pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage[margin=2cm]{geometry}
\usepackage{relsize}

\newcommand{\rchoose}[2]{\left(\mkern-6mu \left({#1 \atop #2}\right) \mkern-6mu \right)}
\newcommand{\dsum}{\sum_{\substack{ k\le n \\ k - \text{нечетное}}}}
\renewcommand{\P}{\text{Pr}}

\begin{document}

\title{Домашняя работа 10}
\author{Антон Афанасьев}
\maketitle

\begin{enumerate}
	\item[1.] Заметим, что так как каждая команда должна сыграть со всеми остальными, то наилучший вариант для первой команды --- это выиграть все оставшиеся матчи. Результаты одного матча не влияют на остальные, и если команда выиграет матч, она получит на очко больше чем если проиграет. По этим же причинам, если первая команда может стать чемпионом проиграв какие-то матчи, она может стать чемпионов выиграв их. Также очевидно, что если первая команда не может стать чемпионом выиграв все оставшиеся матчи, то она не может стать чемпионом проиграв какие-то из них (так она может только уменьшать свой результат).
	
	Итак, считаем, что первая команда выигрывает все свои оставшиеся матчи. Проверим, что существует такой результат всех остальных игр, что ни одна другая команда не получит больше очков, чем первая. Для этого построим сеть следующего вида: добавим по вершине для каждой еще не состоявшейся игры (вершину для игры между командами $i$ и $j$ обозначим $a_{ij}$) и по вершине для всех команд, кроме первой ($b_i$). В вершины-игры проведем по ребру из истока пропускной способности 1, из вершины-игры $a_{ij}$ проведем ребра в вершины-команды $b_i$ и $b_j$ пропускной способности 1. Наконец из вершин-игр проведем в сток по ребру такой пропускной способности, сколько мы можем позволить этой команде выиграть игр, чтобы не превысить результат первой команды. Таким образом поток в этой сети будет соответствовать результатам игр. Мы разрешаем сыграть каждую игру один раз, с одним победителем, и для каждой команды устанавливаем лимит на количество побед. Величина максимального потока ограничена сверху количеством игр. Если в этой сети найдется поток равный количеству игр, то это будет значит, что есть такой способ сыграть все игры, так чтобы первая команда стала чемпионом.
	
	\item[2.] Будем использовать только ребра пропускной способности 1. Построим следующую сеть --- для каждого узла сетки заведем две вершины, связанные ориентированным ребром. В первую вершину другие ребра будут только входить, из второй вершины другие ребра будут только выходить. Таким образом мы не разрешаем проходить через вершину более чем одному пути. Соединим вершины соответствующие соседним узлам ребрами. Вершины на границе соединим с истоком, выделенные вершины соединим со стоком. Поток в этой сети будет соответствовать искомым путям, так как пути не могут пересекаться.
	
	\item[3.] Пусть у нас есть текущий поток $f$ и есть остаточная сеть $R_f$. Тогда
		\begin{enumerate}
			\item Все кратчайшие пути из $s$ в $t$ в $R_f$ войдут в $F$. Так как для кратчайшего пути  для каждой пары последовательных вершин выполняется условие $dist(v) - dist(u) = 1$, иначе путь не был бы кратчайшим.
			\item После нахождения блокирующего потока в каждом из таких путей будет насыщенное ребро, а значит они перестанут быть путями между $s$ и $t$ в новой остаточной сети.
			\item Новых путей такой же, или меньшей длины не появится. Так как мы только увеличиваем поток мы можем смотреть на это так, что мы только удаляем ребра из остаточной сети, а значит новые пути не появляются (если бы они появились, то это значило бы что они были и в изначальной остаточной сети и мы бы нашли их в пункте (a)).
			\item Следовательно, длина кратчайшего пути увеличивается.
		\end{enumerate}
		
\end{enumerate}
\end{document}
