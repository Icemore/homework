\documentclass[10pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{enumitem}
\usepackage[margin=2cm]{geometry}
\usepackage{pseudocode}

\begin{document}

\title{Домашняя работа 1}
\author{Афанасьев Антон}
\maketitle

\begin{enumerate}

	\item Будем добавлять точки в дерево в том порядке, в котором они перечислены в инпуте. Так как они перечислены в порядке неубывания координаты $Y$, а затем в порядке неубывания $X$, то на момент добавления точки $v$ в дерево уже добавлены все точки, координата $Y$ которых меньше $v_y$, а также те, у которых такая же координата $Y$, а $X$ меньше. Таким образом, ограничение по $Y$ выполняется, осталось найти только точки, для которых выполняется ограничение по $X$. Для этого сделаем запрос к дереву, чтобы найти количество точек с $X \leq v_x$.
	
	\item[3.] Будем по очереди добавлять элементы массива в дерево. Получится, что при добавлении очередного элемента, в дереве находятся элементы левее него. Для того, чтобы подсчитать инверсии в которых он участвует достаточно найти количество элементов в дереве, которые больше него (эта операция выполняется за $O(\log n)$). Итого сложность $O(n \log n)$
	
	\item[4.] Отсортируем точки по возрастанию координаты $X$. Добавим точи в таком порядке в персистентное дерево, запоминая его версии после добавления каждой точки. Теперь если мы возьмем версию дерева после добавления точки $v$, то в нем лежат вершины левее этой точки (и те, у которых $x$ такая же, но $y$ меньше, плюс она сама).\\
	Теперь, для обработки запроса $v$, бинарным поиском по координате x найдем нужную версию дерева (не содержащую точек с координатой $x$ больше $v_x$), и сделаем к нему запрос на количество точек, у которых координата $y$ меньше $v_y$.\\
	Итого $O(n \log n)$ на препроцессинг и $O(\log n)$ на запрос.

\end{enumerate}

\end{document}

